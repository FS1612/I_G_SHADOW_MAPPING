<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meridiana Digitale - Roma</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #87CEEB, #98FB98);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            min-width: 280px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #2c3e50;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .time-display {
            font-size: 24px;
            color: #2c3e50;
            margin-top: 15px;
            text-align: center;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
        }

        .info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }

        .shadow-time {
            font-size: 18px;
            color: #d35400;
            text-align: center;
            margin-top: 5px;
        }
        .hour-markers {
            position: absolute;
            pointer-events: none;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <div class="control-group">
            <label for="sunAngle">Azimut del Sole (0°=Nord, 180°=Sud):</label>
            <input type="range" id="sunAngle" min="90" max="270" value="180" step="1">
            <span id="azimuthValue">180°</span>
        </div>
        <div class="control-group">
            <label for="sunHeight">Altezza del Sole:</label>
            <input type="range" id="sunHeight" min="5" max="85" value="45" step="1">
            <span id="heightValue">45°</span>
        </div>
        <div class="control-group">
            <label for="monthDay">Giorno dell'anno (per equazione del tempo):</label>
            <input type="range" id="monthDay" min="1" max="365" value="173" step="1">
            <span id="dayValue">22 Giugno</span>
        </div>
        <div class="control-group">
            <label>
                <input type="checkbox" id="autoRotate" checked> Simulazione Giornaliera
            </label>
        </div>
        <div class="time-display">
            <div id="timeDisplay">12:00</div>
            <div class="shadow-time" id="shadowTime">Ora dell'ombra: 12:00</div>
        </div>
        <div class="info">
            Meridiana per Roma (41.9°N, 12.5°E)<br>
            Le linee orarie sono calcolate astronomicamente.<br>
            L'equazione del tempo corregge la differenza tra tempo solare e civile.
        </div>
    </div>

    <script>
        // Vertex shader
        const vertexShaderSource = `
            precision mediump float;
            attribute vec3 a_position;
            attribute vec3 a_normal;
            attribute vec2 a_texCoord;
            
            uniform mat4 u_modelViewProjectionMatrix;
            uniform mat4 u_modelMatrix;
            uniform mat4 u_normalMatrix;
            uniform vec3 u_lightDirection;
            
            varying vec3 v_position;
            varying vec3 v_normal;
            varying vec2 v_texCoord;
            varying vec3 v_lightDirection;
            varying vec3 v_worldPos;
            
            void main() {
                gl_Position = u_modelViewProjectionMatrix * vec4(a_position, 1.0);
                v_worldPos = (u_modelMatrix * vec4(a_position, 1.0)).xyz;
                v_position = a_position;
                v_normal = normalize((u_normalMatrix * vec4(a_normal, 0.0)).xyz);
                v_texCoord = a_texCoord;
                v_lightDirection = normalize(u_lightDirection);
            }
        `;

        // Fragment shader migliorato per ombra più precisa
        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec3 v_position;
            varying vec3 v_normal;
            varying vec2 v_texCoord;
            varying vec3 v_lightDirection;
            varying vec3 v_worldPos;
            
            uniform vec3 u_color;
            uniform float u_isGround;
            uniform float u_isGnomon;
            uniform float u_isHourLine;
            uniform vec3 u_lightDirection;
            uniform vec3 u_gnomonPosition;
            
            void main() {
                vec3 color = u_color;
                
                vec3 lightDir = normalize(-u_lightDirection);
                float light = max(0.4, dot(v_normal, lightDir));
                
                if (u_isGround > 0.5) {
                    // Effetto erba più realistico
                    float noise1 = sin(v_worldPos.x * 12.0) * sin(v_worldPos.z * 12.0);
                    float noise2 = sin(v_worldPos.x * 20.0 + v_worldPos.z * 20.0);
                    float grass = (noise1 + noise2 * 0.3) * 0.1 + 0.9;
                    
                    vec3 grassColor1 = vec3(0.2, 0.6, 0.2);
                    vec3 grassColor2 = vec3(0.3, 0.7, 0.3);
                    color = mix(grassColor1, grassColor2, grass);
                    
                    // Calcolo ombra dello gnomone più preciso
                    vec3 sunToGround = u_lightDirection;
                    
                    if (sunToGround.y < -0.01) {
                        vec3 gnomonBase = u_gnomonPosition;
                        vec3 gnomonTop = gnomonBase + vec3(0.0, 2.0, 0.0);
                        
                        // Calcola dove l'ombra della cima colpisce il terreno
                        float t = -gnomonTop.y / sunToGround.y;
                        vec3 shadowPoint = gnomonTop + sunToGround * t;
                        
                        // Distanza dal punto d'ombra
                        float distFromShadow = length(v_worldPos.xz - shadowPoint.xz);
                        
                        // Ombra della linea dello gnomone
                        vec3 gnomonDir = normalize(gnomonTop - gnomonBase);
                        vec3 toPoint = v_worldPos - gnomonBase;
                        
                        // Proiezione del punto sulla linea dello gnomone
                        float projLength = dot(toPoint, gnomonDir);
                        vec3 closestPoint = gnomonBase + gnomonDir * clamp(projLength, 0.0, 2.0);
                        
                        // Calcola l'ombra di questo punto
                        t = -closestPoint.y / sunToGround.y;
                        vec3 lineShadePoint = closestPoint + sunToGround * t;
                        float distFromLineShade = length(v_worldPos.xz - lineShadePoint.xz);
                        
                        // Applica l'ombra
                        float shadowIntensity = 1.0;
                        if (distFromShadow < 0.15) {
                            shadowIntensity = 0.3 + 0.4 * smoothstep(0.0, 0.15, distFromShadow);
                        } else if (distFromLineShade < 0.08) {
                            shadowIntensity = 0.4 + 0.3 * smoothstep(0.0, 0.08, distFromLineShade);
                        }
                        
                        color = color * shadowIntensity;
                    }
                }
                
                if (u_isGnomon > 0.5) {
                    // Materiale bronzo per lo gnomone
                    float metallic = sin(v_position.y * 25.0) * 0.1 + 0.9;
                    color = vec3(0.8, 0.6, 0.2) * metallic;
                    
                    float selfShadow = dot(v_normal, lightDir);
                    if (selfShadow < 0.4) {
                        float shadowFactor = smoothstep(0.0, 0.4, selfShadow);
                        color = mix(color * 0.2, color, shadowFactor);
                    }
                }
                
                if (u_isHourLine > 0.5) {
                    // Linee orarie in pietra chiara
                    color = vec3(0.9, 0.9, 0.8);
                }
                
                // Illuminazione finale
                vec3 ambient = vec3(0.3, 0.35, 0.4);
                color = color * light + color * ambient * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Costanti astronomiche per Roma
        const ROME_LATITUDE = 41.9 * Math.PI / 180; // 41.9°N in radianti
        const ROME_LONGITUDE = 12.5 * Math.PI / 180; // 12.5°E in radianti

        // Funzioni astronomiche
        function equationOfTime(dayOfYear) {
            // Equazione del tempo semplificata
            const B = 2 * Math.PI * (dayOfYear - 81) / 365;
            return 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
        }

        function solarDeclination(dayOfYear) {
            // Declinazione solare
            return 23.45 * Math.PI / 180 * Math.sin(2 * Math.PI * (284 + dayOfYear) / 365);
        }

        function hourAngleToAzimuth(hourAngle, declination, latitude) {
            // Converte angolo orario in azimut
            const sinAz = Math.sin(hourAngle) * Math.cos(declination) / 
                         Math.cos(Math.asin(Math.sin(declination) * Math.sin(latitude) + 
                                  Math.cos(declination) * Math.cos(latitude) * Math.cos(hourAngle)));
            return Math.asin(sinAz);
        }

        function calculateSundialHourAngles(latitude) {
            // Calcola gli angoli delle linee orarie per una meridiana orizzontale
            const hourAngles = [];
            for (let hour = 6; hour <= 18; hour++) {
                // Per una meridiana orizzontale, l'angolo è semplicemente proporzionale all'ora
        // 6:00 = 0°, 12:00 = 90°, 18:00 = 180° (rispetto al nord)
        const hourAngle = (hour - 6) * 15 * Math.PI / 180 + Math.PI/2 ; 
                hourAngles.push({
                    hour: hour,
                    angle: hourAngle,
                    displayHour: hour
                });
            }
            return hourAngles;
        }

        function dayOfYearToDateString(day) {
            const months = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 
                           'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
            const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            
            let month = 0;
            let dayInMonth = day;
            
            while (dayInMonth > daysInMonth[month]) {
                dayInMonth -= daysInMonth[month];
                month++;
            }
            
            return `${dayInMonth} ${months[month]}`;
        }

        // Funzioni WebGL (stesse di prima)
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Errore compilazione shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Errore linking program:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Funzioni matematiche per matrici (stesse di prima)
        function mat4() { return new Float32Array(16); }
        function identity(out) {
            out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
            out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            return out;
        }

        function perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = 2 * far * near * nf; out[15] = 0;
            return out;
        }

        function lookAt(out, eye, center, up) {
            const z0 = eye[0] - center[0], z1 = eye[1] - center[1], z2 = eye[2] - center[2];
            let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            const zx = z0 * len, zy = z1 * len, zz = z2 * len;

            const x0 = up[1] * zz - up[2] * zy;
            const x1 = up[2] * zx - up[0] * zz;
            const x2 = up[0] * zy - up[1] * zx;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            const xx = len ? x0 / len : 0, xy = len ? x1 / len : 0, xz = len ? x2 / len : 0;

            const y0 = zy * xz - zz * xy;
            const y1 = zz * xx - zx * xz;
            const y2 = zx * xy - zy * xx;

            out[0] = xx; out[1] = y0; out[2] = zx; out[3] = 0;
            out[4] = xy; out[5] = y1; out[6] = zy; out[7] = 0;
            out[8] = xz; out[9] = y2; out[10] = zz; out[11] = 0;
            out[12] = -(xx * eye[0] + xy * eye[1] + xz * eye[2]);
            out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
            out[14] = -(zx * eye[0] + zy * eye[1] + zz * eye[2]);
            out[15] = 1;
            return out;
        }

        function multiply(out, a, b) {
            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

            let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

            b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        }

        // Creazione geometrie migliorate
        function createPlane(size) {
            const segments = 60;
            const vertices = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    const x = (i / segments - 0.5) * size * 2;
                    const z = (j / segments - 0.5) * size * 2;
                    const y = 0;

                    vertices.push(
                        x, y, z,
                        0, 1, 0,
                        i / segments,
                        j / segments
                    );
                }
            }

            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * (segments + 1) + j;
                    const b = a + 1;
                    const c = (i + 1) * (segments + 1) + j;
                    const d = c + 1;

                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }

            return { vertices: new Float32Array(vertices), indices: new Uint16Array(indices) };
        }

        function createGnomon() {
            const height = 2;
            const width = 0.05;

            const vertices = [
                // Base
                -width, 0, -width, 0, 1, 0, 0, 0,
                width, 0, -width, 0, 1, 0, 1, 0,
                width, 0, width, 0, 1, 0, 1, 1,
                -width, 0, width, 0, 1, 0, 0, 1,
                // Top
                -width, height, -width, 0, 1, 0, 0, 0,
                width, height, -width, 0, 1, 0, 1, 0,
                width, height, width, 0, 1, 0, 1, 1,
                -width, height, width, 0, 1, 0, 0, 1,
            ];

            const indices = [
                0, 1, 5, 0, 5, 4,
                1, 2, 6, 1, 6, 5,
                2, 3, 7, 2, 7, 6,
                3, 0, 4, 3, 4, 7,
                4, 5, 6, 4, 6, 7
            ];

            return { vertices: new Float32Array(vertices), indices: new Uint16Array(indices) };
        }

        function createHourLines() {
            const hourAngles = calculateSundialHourAngles(ROME_LATITUDE);
            const lines = [];

            hourAngles.forEach(hourData => {
                const angle = hourData.angle;
                const hour = hourData.hour;
                
                // Crea una linea dalla base dello gnomone verso l'esterno
                const length = 8;
                const width = 0.02;
                
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                // Linea principale
                const vertices = [];
                const indices = [];
                
                // Crea una striscia sottile per la linea oraria
                for (let i = 0; i <= 20; i++) {
                    const t = i / 20;
                    const x = sin * t * length;
                    const z = cos * t * length;
                    
                    // Due punti per la larghezza della linea
                    const perpX = -cos * width;
                    const perpZ = sin * width;
                    
                    vertices.push(
                        x + perpX, 0.01, z + perpZ, 0, 1, 0, 0, t,
                        x - perpX, 0.01, z - perpZ, 0, 1, 0, 1, t
                    );
                    
                    if (i < 20) {
                        const base = i * 2;
                        indices.push(base, base + 1, base + 2);
                        indices.push(base + 1, base + 3, base + 2);
                    }
                }
                
                // Marcatore dell'ora
                const markerSize = 0.8;
                const markerX = sin * (length - 1);
                const markerZ = cos * (length - 1);
                
                const markerVertices = [
                    markerX - markerSize, 0.1, markerZ - markerSize, 0, 1, 0, 0, 0,
                    markerX + markerSize, 0.1, markerZ - markerSize, 0, 1, 0, 1, 0,
                    markerX + markerSize, 0.1, markerZ + markerSize, 0, 1, 0, 1, 1,
                    markerX - markerSize, 0.1, markerZ + markerSize, 0, 1, 0, 0, 1,
                    
                    markerX - markerSize, 1.0, markerZ - markerSize, 0, 1, 0, 0, 0,
                    markerX + markerSize, 1.0, markerZ - markerSize, 0, 1, 0, 1, 0,
                    markerX + markerSize, 1.0, markerZ + markerSize, 0, 1, 0, 1, 1,
                    markerX - markerSize, 1.0, markerZ + markerSize, 0, 1, 0, 0, 1,
                ];
                
                const markerIndices = [
    0, 1, 2, 0, 2, 3, // bottom
    4, 7, 6, 4, 6, 5, // top (corretti)
    0, 4, 5, 0, 5, 1, // sides (corretti)
    1, 5, 6, 1, 6, 2,
    2, 6, 7, 2, 7, 3,
    3, 7, 4, 3, 4, 0
];
                
                lines.push({
                    lineVertices: new Float32Array(vertices),
                    lineIndices: new Uint16Array(indices),
                    markerVertices: new Float32Array(markerVertices),
                    markerIndices: new Uint16Array(markerIndices),
                    hour: hour,
                    angle: angle
                });
            });

            return lines;
        }

        // Inizializzazione WebGL
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL non supportato!');
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Attributi e uniform
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const normalLocation = gl.getAttribLocation(program, 'a_normal');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

        const mvpMatrixLocation = gl.getUniformLocation(program, 'u_modelViewProjectionMatrix');
        const modelMatrixLocation = gl.getUniformLocation(program, 'u_modelMatrix');
        const normalMatrixLocation = gl.getUniformLocation(program, 'u_normalMatrix');
        const colorLocation = gl.getUniformLocation(program, 'u_color');
        const lightDirectionLocation = gl.getUniformLocation(program, 'u_lightDirection');
        const isGroundLocation = gl.getUniformLocation(program, 'u_isGround');
        const isGnomonLocation = gl.getUniformLocation(program, 'u_isGnomon');
        const isHourLineLocation = gl.getUniformLocation(program, 'u_isHourLine');
        const gnomonPositionLocation = gl.getUniformLocation(program, 'u_gnomonPosition');

        // Creazione geometrie
        const planeGeometry = createPlane(12);
        const gnomonGeometry = createGnomon();
        const hourLines = createHourLines();

        // Buffer
        function createBuffer(data) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
            return buffer;
        }

        function createIndexBuffer(data) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
            return buffer;
        }

        const planeVertexBuffer = createBuffer(planeGeometry.vertices);
        const planeIndexBuffer = createIndexBuffer(planeGeometry.indices);
        const gnomonVertexBuffer = createBuffer(gnomonGeometry.vertices);
        const gnomonIndexBuffer = createIndexBuffer(gnomonGeometry.indices);

        // Buffer per le linee orarie
        // Buffer per le linee orarie
                const hourLineBuffers = hourLines.map(line => ({
            lineVertexBuffer: createBuffer(line.lineVertices),
            lineIndexBuffer: createIndexBuffer(line.lineIndices),
            markerVertexBuffer: createBuffer(line.markerVertices),
            markerIndexBuffer: createIndexBuffer(line.markerIndices),
            hour: line.hour,
            angle: line.angle
        }));

        // Controlli della camera
        let cameraDistance = 20;
        let cameraAngleX = -45;
        let cameraAngleY = 45;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.5;
                cameraAngleX += deltaY * 0.5;
                cameraAngleX = Math.max(-80, Math.min(80, cameraAngleX));
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(5, Math.min(30, cameraDistance));
        });

        // Controlli UI
        const sunAngleSlider = document.getElementById('sunAngle');
        const sunHeightSlider = document.getElementById('sunHeight');
        const monthDaySlider = document.getElementById('monthDay');
        const autoRotateCheckbox = document.getElementById('autoRotate');
        const azimuthValue = document.getElementById('azimuthValue');
        const heightValue = document.getElementById('heightValue');
        const dayValue = document.getElementById('dayValue');
        const timeDisplay = document.getElementById('timeDisplay');
        const shadowTime = document.getElementById('shadowTime');

        sunAngleSlider.addEventListener('input', updateDisplay);
        sunHeightSlider.addEventListener('input', updateDisplay);
        monthDaySlider.addEventListener('input', updateDisplay);

        function updateDisplay() {
            azimuthValue.textContent = sunAngleSlider.value + '°';
            heightValue.textContent = sunHeightSlider.value + '°';
            dayValue.textContent = dayOfYearToDateString(parseInt(monthDaySlider.value));
        }

        // Calcolo del tempo dalla posizione del sole
 function calculateTimeFromSun(azimuth, elevation, dayOfYear) {
    // Controllo se il sole è sotto l'orizzonte (notte)
    if (elevation <= 0) return "Notte";
    
    // Controllo se il sole è in una posizione impossibile per Roma
    // Il sole a Roma non può mai essere a nord (azimut 315°-45°)
    if (azimuth > 270 || azimuth < 90) return "Sole non visibile";
    
    // Calcolo semplificato: converte azimut in ore
    // 90° = 6:00, 180° = 12:00, 270° = 18:00
    let solarHour = (azimuth -90) / 15 + 6;
    
    // Applica l'equazione del tempo
    const eot = equationOfTime(dayOfYear);
    const civilTime = solarHour - eot / 60;
    
    const hours = Math.floor(civilTime);
    const minutes = Math.floor((civilTime - hours) * 60);
    
    if (hours < 6 || hours > 17) return "Fuori orario";
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
}

        // Calcolo dell'ora dall'ombra
        function calculateShadowTime(lightDirection, dayOfYear) {
            if (lightDirection[1] >= -0.01) return "Notte";
            
            // Calcola l'angolo dell'ombra sul piano orizzontale
            const shadowAngle = Math.atan2(lightDirection[0], -lightDirection[2]);
            
            // Trova la linea oraria più vicina
            const hourAngles = calculateSundialHourAngles(ROME_LATITUDE);
            let closestHour = 12;
            let minDiff = Math.PI;
            
            hourAngles.forEach(hourData => {
                const diff = Math.abs(shadowAngle - hourData.angle);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestHour = hourData.hour;
                }
            });
            
            // Interpolazione per maggiore precisione
            // Converte l'angolo dell'ombra direttamente in ore
   // L'ombra è opposta al sole: quando il sole è a est (mattina), l'ombra punta a ovest
    const exactHour = 12 - (shadowAngle * 6 / (Math.PI/2));
            
            // Applica l'equazione del tempo
            const eot = equationOfTime(dayOfYear);
            const civilTime = exactHour - eot / 60;
         
            const hours = Math.floor(civilTime);
            const minutes = Math.floor((civilTime - hours) * 60);
            
            if (hours < 6 || hours > 17) return "Fuori orario";  // Estendi fino alle 20
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        // Funzione di rendering
        function drawObject(vertexBuffer, indexBuffer, indexCount, color, isGround = false, isGnomon = false, isHourLine = false) {
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 32, 0);
            
            gl.enableVertexAttribArray(normalLocation);
            gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 32, 12);
            
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 32, 24);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            
            gl.uniform3fv(colorLocation, color);
            gl.uniform1f(isGroundLocation, isGround ? 1.0 : 0.0);
            gl.uniform1f(isGnomonLocation, isGnomon ? 1.0 : 0.0);
            gl.uniform1f(isHourLineLocation, isHourLine ? 1.0 : 0.0);
            
            gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
        }
        function updateHourMarkers() {
    // Rimuovi i marcatori esistenti
    document.querySelectorAll('.hour-markers').forEach(el => el.remove());
    
    const hourAngles = calculateSundialHourAngles(ROME_LATITUDE);
    
    // Usa le stesse matrici del rendering 3D
    const projectionMatrix = mat4();
    const viewMatrix = mat4();
    const mvpMatrix = mat4();
    
    perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
    
    // Posizione camera (stessa del render)
    const cameraX = Math.sin(cameraAngleY * Math.PI / 180) * Math.cos(cameraAngleX * Math.PI / 180) * cameraDistance;
    const cameraY = Math.sin(cameraAngleX * Math.PI / 180) * cameraDistance;
    const cameraZ = Math.cos(cameraAngleY * Math.PI / 180) * Math.cos(cameraAngleX * Math.PI / 180) * cameraDistance;
    
    lookAt(viewMatrix, [cameraX, cameraY, cameraZ], [0, 0, 0], [0, 1, 0]);
    multiply(mvpMatrix, projectionMatrix, viewMatrix);
    
    hourAngles.forEach(hourData => {
        const angle = hourData.angle;
        const length = 8; // Distanza dal centro
        
        // Posizione 3D del marcatore
        const x3d = Math.sin(angle) * length;
        const y3d = 0.5; // Altezza sul piano
        const z3d = Math.cos(angle) * length;
        
        // Trasforma in coordinate schermo usando la matrice MVP
        const worldPos = [x3d, y3d, z3d, 1];
        
        // Moltiplica per la matrice MVP
        const clipX = worldPos[0] * mvpMatrix[0] + worldPos[1] * mvpMatrix[4] + worldPos[2] * mvpMatrix[8] + worldPos[3] * mvpMatrix[12];
        const clipY = worldPos[0] * mvpMatrix[1] + worldPos[1] * mvpMatrix[5] + worldPos[2] * mvpMatrix[9] + worldPos[3] * mvpMatrix[13];
        const clipW = worldPos[0] * mvpMatrix[3] + worldPos[1] * mvpMatrix[7] + worldPos[2] * mvpMatrix[11] + worldPos[3] * mvpMatrix[15];
        
        // Converti in coordinate schermo
        if (clipW > 0) { // Solo se visibile
            const ndcX = clipX / clipW;
            const ndcY = clipY / clipW;
            
            const screenX = (ndcX + 1) * 0.5 * canvas.width;
            const screenY = (1 - ndcY) * 0.5 * canvas.height;
            
            // Crea elemento HTML per il numero
            const marker = document.createElement('div');
            marker.className = 'hour-markers';
            marker.textContent = hourData.hour;
            marker.style.left = screenX + 'px';
            marker.style.top = screenY + 'px';
            marker.style.transform = 'translate(-50%, -50%)';
            marker.style.fontSize = '24px';
            marker.style.fontWeight = 'bold';
            document.body.appendChild(marker);
        }
    });
}
        let animationTime = 0;

        function render() {
            try {
                // Aggiorna il tempo se l'animazione è attiva
                if (autoRotateCheckbox.checked) {
                    animationTime += 0.01;
                    const sunAngle = 90 + ((animationTime * 15) % 180);;
                    sunAngleSlider.value = sunAngle;
                    updateDisplay();
                }

                const sunAngle = parseFloat(sunAngleSlider.value);
                const sunHeight = parseFloat(sunHeightSlider.value);
                const dayOfYear = parseInt(monthDaySlider.value);

                // Calcola la direzione della luce solare
                const azimuthRad = sunAngle * Math.PI / 180;
const elevationRad = sunHeight * Math.PI / 180;

const lightDirection = [
    Math.sin(azimuthRad) * Math.cos(elevationRad),
    -Math.sin(elevationRad),
    Math.cos(azimuthRad) * Math.cos(elevationRad)
];

                // Aggiorna i display del tempo
                const currentTime = calculateTimeFromSun(sunAngle, sunHeight, dayOfYear);
                const shadowTimeStr = calculateShadowTime(lightDirection, dayOfYear);
                
                timeDisplay.textContent = currentTime;
                shadowTime.textContent = `Ora dell'ombra: ${shadowTimeStr}`;

                // Setup WebGL
                gl.clearColor(0.5, 0.7, 1.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.useProgram(program);

                // Matrici di vista e proiezione
                const projectionMatrix = mat4();
                const viewMatrix = mat4();
                const modelMatrix = mat4();
                const mvpMatrix = mat4();
                const normalMatrix = mat4();

                perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);

                // Posizione della camera
                const cameraX = Math.sin(cameraAngleY * Math.PI / 180) * Math.cos(cameraAngleX * Math.PI / 180) * cameraDistance;
                const cameraY = Math.sin(cameraAngleX * Math.PI / 180) * cameraDistance;
                const cameraZ = Math.cos(cameraAngleY * Math.PI / 180) * Math.cos(cameraAngleX * Math.PI / 180) * cameraDistance;

                lookAt(viewMatrix, [cameraX, cameraY, cameraZ], [0, 0, 0], [0, 1, 0]);

                // Uniform globali
                gl.uniform3fv(lightDirectionLocation, lightDirection);
                gl.uniform3fv(gnomonPositionLocation, [0, 0, 0]);

                // Disegna il terreno
identity(modelMatrix);
multiply(mvpMatrix, projectionMatrix, viewMatrix);
multiply(mvpMatrix, mvpMatrix, modelMatrix);

gl.uniformMatrix4fv(mvpMatrixLocation, false, mvpMatrix);
gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
gl.uniformMatrix4fv(normalMatrixLocation, false, modelMatrix);

drawObject(planeVertexBuffer, planeIndexBuffer, planeGeometry.indices.length, [0.3, 0.7, 0.3], true);

                // Disegna le linee orarie
                hourLineBuffers.forEach(lineData => {
    // Linea oraria
    drawObject(lineData.lineVertexBuffer, lineData.lineIndexBuffer, 
              lineData.lineIndexBuffer, [0.9, 0.9, 0.8], false, false, true);
    
    // Marcatore dell'ora
    drawObject(lineData.markerVertexBuffer, lineData.lineIndexBuffer, 
              lineData.lineIndexBuffer, [0.7, 0.7, 0.6], false, false, true);
});

                // Disegna lo gnomone
                drawObject(gnomonVertexBuffer, gnomonIndexBuffer, gnomonGeometry.indices.length, [0.8, 0.6, 0.2], false, true);

            } catch (error) {
                console.error('Errore durante il rendering:', error);
            }
            
            requestAnimationFrame(render);
            updateHourMarkers();
        }

        // Inizializza e avvia con controllo errori
        try {
            updateDisplay();
            console.log('Avvio rendering...');
            render();
        } catch (error) {
            console.error('Errore durante l\'inizializzazione:', error);
            document.body.innerHTML += '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 10px;">Errore: ' + error.message + '</div>';
        }
    </script>
</body>

</html>